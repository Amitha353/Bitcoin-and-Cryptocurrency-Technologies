--------------------------------------------------------------------------------------------------------------------------------------
3.1 Bitcoin Transactions
--------------------------------------------------------------------------------------------------------------------------------------
Recap : Bitcoin consensus

Bitcoin consensus gives us:
1. Append-only ledger - datastructure that we can only write to and once data is there , it's forever.
2. Decentralized consensus - decentralized protocol for establishing the value of that ledger.
3. Miners to validate transactions. (no double spends);

I. An account-based ledger (not Bitcoin)
------------------
(Simplification : only one transaction per block)
       ---------------------------------------------------------
 |    |Create 25 coins and credit to Alice (Asserted by Miners) |
 |    -----------------------------------------------------------
t|    | Transfer 17 coins from Alice to Bob (Signed by Alice)   |
i|    -----------------------------------------------------------
m|    | Transfer 8 coins from Bob to Carol (Signed by Bob)      |
e|    -----------------------------------------------------------
 |    | Transfer 5 coins from Carol to Alice (Signed by Bob)    |
 |    -----------------------------------------------------------
 |    | Transfer 15 coins from Alice to David (Signed by Alice) |  <- Is this valid? Requires to know the data in each members account
 |    -----------------------------------------------------------      Need to go back to the history(account, genesis to keep track)
\ /  

It is an infinite backward scan, because of the need to keep track of transactions - and add them up tally the transaction - Bitcoin doen't follow an account-based ledger;
Bitcoin uses a ledger that keeps track of transactions.

II. A transaction-based ledger (Bitcoin)
-----------------------------------------'
(Simplification : only one transaction per block)
 |   -----------------------------------------------
 |   |1                                            |
 |   |   Inputs: ∅                                 |   (First transaction)
 |   |   Outputs: 25.0 -> Alice                    |      
 |   |                                             |          
 |   -----------------------------------------------
T|   |2                                            |
I|   |   Inputs: 1[0]                              |      
M|   |   Outputs: 17.0->Bob, 8.0->Alice            |      
E|   |                            (Signed by Alice)|          
 |   -----------------------------------------------
 |   |3                                            |
 |   |   Inputs: 2[0]                              |      
 |   |   Outputs: 8.0->Carol, 7.0->Bob             |      
 |   |                              (Signed by Bob)|          
 |   -----------------------------------------------
 |   |4                                            |
 |   |   Inputs: 2[1]                              |  <- Is it valid ?  (Finite scan to check validity)  
 |   |   Outputs: 6.0->David, 2.0->Alice           |      
 |   |                            (Signed by Alice)|          
 |   -----------------------------------------------
 |
\ /

-> Transactions explicitly specify the number of inputs and the number of outputs.

-> Transactions also have a unique identifier - here noted by serial number, by actually implemented via "hash pointer";

-> Transaction 1 -> No input since it is newly created , but an output of 25 coins going to Alice, and since it is a new transaction no new coins are created here.

-> Transaction 2 -> Alice wants to send coins to Bob;
Inputs : 1[0] -> 25.0 coins
Outputs : (2) -> Bob (17); (Remainder) -> 8 coins -> payed to change address -> Back to Alice;
Signed by Alice -> validation of the transaction.
**** Always completely need to consume the output of the previous transaction.

-> Here it is much easier to look at the transaction and know whether the transaction is valid or not. It requires a finite scan.
Example: Transaction 4 (By looking at the previous transaction 2[1] -> able to validate the transaction)
Inputs : 2[1] -> Signed By Alice -> Value = (2nd block, 2nd output) = 8;
Outputs : 6.0 -> David, 2.0 -> Alice; = total bitcoins = 8

* Joint Payments
----------------------

 |   -----------------------------------------------
 |   |1                                            |
 |   |   Inputs: ∅                                 |   (First transaction)
 |   |   Outputs: 25.0 -> Alice                    |      
 |   |                                             |          
 |   -----------------------------------------------
T|   |2                                            |
I|   |   Inputs: 1[0]                              |      
M|   |   Outputs: 17.0->Bob, 8.0->Alice            |      
E|   |                            (Signed by Alice)|          
 |   -----------------------------------------------
 |   |3                                            |
 |   |   Inputs: 2[0]                              |      
 |   |   Outputs: 8.0->Carol, 7.0->Bob             |      
 |   |                              (Signed by Bob)|          
 |   -----------------------------------------------
 |   |4                                            |
 |   |   Inputs: 2[1]                              |    
 |   |   Outputs: 6.0->David, 2.0->Alice           | ----     
 |   |                            (Signed by Alice)|    |  6 -> David     
 |   -----------------------------------------------    |  2 -> Alice
 |   |5                                            |    |
 |   |   Inputs: 4[0], 4[1]                        | <--|   
 |   |   Outputs: 6.0->Bob                         |  <--- Joint Payment (2 inputs, 1 outputs)
 |   |        (Signed by David) , (Signed by Alice)|  <--- 2 Signatures                
 |   -----------------------------------------------
 |
\ /

The real deal : A Bitcoin transaction
--------------------
-> It's actually a compact binary format of the data shown that it gets compiled into.
-> Data structure - 3 parts - Metadata, inputs, outputs.

1. Metadata
              {
transaction hash -> "hash" : "5a57fdg93....2443",
                    "ver":1,
housekeeping        "vin_sz":2,
                    "vout_sz":1,
                    "lock_time":0, **
                    "size":404,
                     ....
              }             
2. Input
       "in": [
              {
              "prev_out": {
                     "hash": "3be4...89gfh",    <----- Previous transactions
                     "n":0
              },
              "scriptSig": "3f3we46",   <----- Signatures
              },
              ....
            ],
 3. Output
       "out": [
              {
                     "value": "10.235969544",                    <-- Each output can have value.sum(output) < sum(input)
                     "scriptPubKey": "OP_DUP_OP_HASH89324..568   <---- Script - with public key      
                     OP_EQUALVERIFY OP_CHECKSIG"
              },
              ...
       ]
 
 Q . In a typical transaction

a. There is one signature that covers all the inputc  - false
b. Each input contains a signature                    - true 
c. There is one signature that covers all the output  - false
d. Each output contains a signature                   - false

--------------------------------------------------------------------------------------------------------------------------------------
3.2 Bitcoin Scripts
--------------------------------------------------------------------------------------------------------------------------------------
-> Each transaction output key scpecifies and script.

"out": [
              {
                     "value": "10.235969544",                    <-- Each output can have value.sum(output) < sum(input)
                     "scriptPubKey": "OP_DUP_OP_HASH89324..568   <---- Script - with public key      
                     OP_EQUALVERIFY OP_CHECKSIG"
              },
              ...
       ]
       
 * Inorder to redeem a previous transaction by signing with the correct public key 
 -> Input "address" and output "address" are both scripts, they are concatenated together and run, if successful it is a valid. transaction.
            ----------------------------
              
scriptSig   304521245522...
            45344gsjdui9...                   input
                 
            -----------------------------
              
             OP_DUP
scriptPubKey OP_HASH160
             69efrfg18..                     output
             OP_EQUALVERIFY OP_CHECKSIG
             
             -----------------------------
             
* Bitcoin scripting language ("Script")
------------------
Design goals
 1. Built for Bitcoin (inspired by Forth)
 2. Simple, compact
 3. Support for cryptography (hash functions, compute signatures, verify signatures, etc)
 4. Stack-based language
 5. Limits on time / memory
 6. No looping
 
Bitcoin script execution example
------------
-> If data is seen it's pushed onto the stack.
-> Here - write data into the memory (stack);

<sig> <pubkey> OP_DUP OP_HASH160 <pubKeyHash?> OP_EQUALVERIFY OP_CHECKSIG

# OP_DUP -> take value on top of the stack, pop off, and write two copies back to stack. 
# OP_HASH160 -> Take the value on top of stack and compute cryptographic hash of it.
# OP_EQUALVERIFY -> Check if the two values at the top of stack equal.
# OP_CHECKSIG -> Verify the signatures

* Stack structure -> command by command
------
<sig> <pubkey> OP_DUP OP_HASH160 <pubKeyHash?> OP_EQUALVERIFY OP_CHECKSIG
i.   <sig>
  ----------
 | <sig>    |
  ----------
ii. <pubkey>

 ------------
 | <pubkey> |
  ------- ---
 | <sig>    |
  -----------
iii. OP_DUP

 ------------
 | <pubkey> |
 ------------
 | <pubkey> |
  ------- ---
 | <sig>    |
  -----------
iv. OP_HASH160

 -------------
 |<pubkeyhash>|
 --------------
 | <pubkey>   |
  ------- ---- 
 | <sig>      |
  -------------

v. <pubKeyHash?>
  -------------
 |<pubKeyHash?>| <--sender
 -------------- 
 |<pubkeyhash> | <- recipient
 --------------
 | <pubkey>    |
  ------------- 
 | <sig>       |
  -------------
 
vi. OP_EQUALVERIFY - consumes <pubkeyhash> and <pubkeyhash?>
 
 --------------
 | <pubkey>    |
  ------------- 
 | <sig>       |
  -------------
 
 vii. OP_CHECKSIG - > checks the transaction signature. -> pops the commands from the stack, public key is already verified.
 
* Bitcoin script instructions
------------------------------
* Small -> 256 opcodes total (15 disable, 75 reserved)
       * Arithmetic
       * If/then
       * Logic/data handling
       * Crypto!
              * Hashes
              * Signature Vwerifications
              * Multi-signature verification -> Instruction -> OP_CHECKMULTISIG

* OP_CHECKMULTISIG
--------------------
-> Built-in support for joint signatures
-> Specify n public keys
-> Specify t (threshold)
-> Verifications requires t signatures (t of n signatures need to be valid);
# Bug: Extra data-value popped off and ignored;

* Bitcoin scripts in practice (2014 ->)
-------------------------------
1. Most nodes whitelist known scripts.
2. 99.9% - simple signature check.
3. ~0.01% are MULTISIG
4. ~0.01% are Pay-to-Script-Hash
6. Remainder are error, proof-of-burn scripts.

* Proof-of-burn script
---------------------
-> It can never be redeemed , those coins have been destroyed and can't be used again.
-> OP_RETURN
-> Used for:
    a. <arbitrary data> -> (stays forever) timestamp, write something in exchange for a little loss of Bitcoins.
    b. use alternative coin to bitcoin.
    
* Pay-to-Script-Hash script
-----------------------------
 * Rather than the sender having to send a script as an address they just send a hash of the script.
 * Eventaully added to BITCOIN.
              
              STEP 1                                    STEP 2
       (redemption script has right hash)    (redemption script-desearalized - actual signture check)
            ----------------------------         ----------------------------
              
Recipient   <signature>                          <signature>
            <<pubkey> OP_CHECKSIG>                   
                 
            -----------------------------        ----------------------------
              
             OP_HASH160
 Sender      <hash of redemption script>            <pubkey>       
             OP_EQUAL                              OP_CHECKSIG
             
             -----------------------------       ----------------------------

Q. Bitcoin’s script supports instructions whose effect is: (check all that apply)

a. Adding two numbers                  - true
b. Conditional execution (if/then)     - true
c. Looping                             - false
d. Recursion                           - false   
e. Hashing                             - true
--------------------------------------------------------------------------------------------------------------------------------------
3.3 Applications of Bitcoin scripts
--------------------------------------------------------------------------------------------------------------------------------------

1. Escrow Transactions 
 ---------------------
-> Online Transactions
Example:
- Problem : Alice wants to buy online from Bob. Alice doesn't want to pay until Bob ships. Bob doesn't want to ship until after Alice pays.

- Solution : Introduce a third party and do ("escrow" transaction); 

Alice  <----------------------------------------------------------------> Bob
               ---------------------------------------------
              | Pay x to 2-of-3 Alice, Bob, Judy (MULTISIG) |
              |                               (signed Alice)|
              -----------------------------------------------


  # Alice will not pay directly to Bob, but will instead create a MULTISIG transaction that requires two or three signatures to redeem a coin (Say -> Alice, Bob, , Judy) - Judy is a Judge that comes into place in case of any disputes.
  # Alice creates the transaction with the desired amount with 2-out of 3 MULTISIG between Alice, Bob and Judy.
  # Alice signs the transaction redeeming some coins that she owns and this will get published in the Block-chain.
  # At this point, the coins are held in "escrow" between Alice, Bob and Judy and any two of them can specify where the coins should go.
  # Bob is now satisified and is safe to send the goods over to Alcie,
  
  # In normal case (hope) Alice and Bob are both honest and goods arrive on time and Alice wants to release the amount from escrow so that Bob receives the money.
  # If the above situtation occurs then Alice and Bob can both sign a transaction, redeeming the funds from escrow and consuming it. Moreover Judy din't have to get involved in the transaction, no dispute.
  
       (normal case)
        ____________________________________________
       | Pay x to Bob                              |
       |                         SIGNED(ALICE,BOB) |
       |___________________________________________|
  
                        _________________
                       /                /|
                      /________________/ |
                     |                |  |
                     |  To :Alice     |  | 
                     |  From: Bob     | /
                     |________________|/
  Alice  <----------------------------------------------------------------> Bob
               ---------------------------------------------
              | Pay x to 2-of-3 Alice, Bob, Judy (MULTISIG) |
              |                               (signed Alice)|
              -----------------------------------------------

  
  # In case the transaction fails -> goods are lost, not delivered then Alice doen't want to pay and wants to get back her money.
  # In this case both Alice and Bob are both not gonna sign a transaction and release the money to Bob, or deny Alice'd fraud claim.
  # Judy get involved to solve the dispute, she will sign the transaction with the honest party . Here there will be 2-out-3 signatures to release the money from the transaction.
  - Alice is honest, Judy, Alice sign the transaction and money is refunded to Alice.
  - Bob is honest, Judy, Bob can sign a transaction and money sent to Bob.
  
  
  (dispute case)
        ____________________________________________
       | Pay x to Alice                            |
Judy   |                         SIGNED(ALICE,JUDY)|
       |___________________________________________|
  
                        _________________
                       /                /|
                      /________________/ |
                     |                |  |
                     |  To :Alice     |  | 
                     |  From: Bob     | /
                     |________________|/
  Alice  <----------------------------------------------------------------> Bob
               ---------------------------------------------
              | Pay x to 2-of-3 Alice, Bob, Judy (MULTISIG) |
              |                               (signed Alice)|
              -----------------------------------------------
-----------------------------------------------------
  (dispute case)
        ____________________________________________
       | Pay x to Bob                              |
Judy   |                         SIGNED(BOB,JUDY)  |
       |___________________________________________|
  
                        _________________
                       /                /|
                      /________________/ |
                     |                |  |
                     |  To :Alice     |  | 
                     |  From: Bob     | /
                     |________________|/
  Alice  <----------------------------------------------------------------> Bob
               ---------------------------------------------
              | Pay x to 2-of-3 Alice, Bob, Judy (MULTISIG) |
              |                               (signed Alice)|
              -----------------------------------------------

2. Green Address
-----------------
Problem : Alice wants to pay Bob. Bob can't wait 6 verifications to guard against double-spends, or is offline completely. 
(To send money to a person using Bitcoin without the recipient being able to access the block-chain - need to introduce another third party which is the bank).
(Green Address - provides a means to do payments quickly without accessing the block-chain).

-> Alice contacts the Bank and asks them  to help transfer money to Bob.
-> Bank debits amount from Alice's Bank account and draws a transaction from one of the Banks green address to Bob, and some amount to the bank itself.
-> Since money is coming from the bank , the bank assures/guarentees there is no double spend and the address (green address) - bank controlled address.
-> Bob gets the transaction and can choose to accept it based on the banks guarentees and can evetually be uin the block-chain.
-> This is not a Bitcoin enforced guarantee, but instead it is a real-world guarantee.

-> Two most prominent services that implemented green addresses - Instawallet and Mount Gox both collapsed. Therefore not popular protocol.

           Bank
  payment / |
        /   | 
      /    \ /
    /   _____________________________________________   (out of network/block-chain)     
Alice    | Pay x to Bob, y to Bank  (No double spend)  |      Bob
         |                                SIGNED(BANK) |  
         |_____________________________________________|
         
3. Efficient micro-payments
-----------------------------
Problem : Alice wants to pay Bob for each minute of phone service. She doesn't want to incur transaction fee every minute.
- It won't be optimum to create a Bitcoin transaction for every minute Alice is on call. then the transaction fee incured will be too high for the service. Too many transaction fees -  not optimum.

-> Solution: Create a low value transaction for every minute that Alice talks on phone. There is a problem with this system is that the transactions might all be very low value and the transaction fees might be too high.

-> Required solution : Combine all these small payments into one big payment at the end. It can be done with serial micro-payment.

# Start with a MULTISIG transaction that pays the maximum amount Alice would ever need to spend to a MULTISIG transaction requiring both Alice and Bob to sign to release the coins.
# After 1 minute of the service, Alice signs the transaction spending those coins signed in the MULTISIG address, sending one coin to Bob and returning the rest to Alice.








  
       
 
 

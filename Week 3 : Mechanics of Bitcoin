--------------------------------------------------------------------------------------------------------------------------------------
3.1 Bitcoin Transactions
--------------------------------------------------------------------------------------------------------------------------------------
Recap : Bitcoin consensus

Bitcoin consensus gives us:
1. Append-only ledger - datastructure that we can only write to and once data is there , it's forever.
2. Decentralized consensus - decentralized protocol for establishing the value of that ledger.
3. Miners to validate transactions. (no double spends);

I. An account-based ledger (not Bitcoin)
------------------
(Simplification : only one transaction per block)
       ---------------------------------------------------------
 |    |Create 25 coins and credit to Alice (Asserted by Miners) |
 |    -----------------------------------------------------------
t|    | Transfer 17 coins from Alice to Bob (Signed by Alice)   |
i|    -----------------------------------------------------------
m|    | Transfer 8 coins from Bob to Carol (Signed by Bob)      |
e|    -----------------------------------------------------------
 |    | Transfer 5 coins from Carol to Alice (Signed by Bob)    |
 |    -----------------------------------------------------------
 |    | Transfer 15 coins from Alice to David (Signed by Alice) |  <- Is this valid? Requires to know the data in each members account
 |    -----------------------------------------------------------      Need to go back to the history(account, genesis to keep track)
\ /  

It is an infinite backward scan, because of the need to keep track of transactions - and add them up tally the transaction - Bitcoin doen't follow an account-based ledger;
Bitcoin uses a ledger that keeps track of transactions.

II. A transaction-based ledger (Bitcoin)
-----------------------------------------'
(Simplification : only one transaction per block)
 |   -----------------------------------------------
 |   |1                                            |
 |   |   Inputs: ∅                                 |   (First transaction)
 |   |   Outputs: 25.0 -> Alice                    |      
 |   |                                             |          
 |   -----------------------------------------------
T|   |2                                            |
I|   |   Inputs: 1[0]                              |      
M|   |   Outputs: 17.0->Bob, 8.0->Alice            |      
E|   |                            (Signed by Alice)|          
 |   -----------------------------------------------
 |   |3                                            |
 |   |   Inputs: 2[0]                              |      
 |   |   Outputs: 8.0->Carol, 7.0->Bob             |      
 |   |                              (Signed by Bob)|          
 |   -----------------------------------------------
 |   |4                                            |
 |   |   Inputs: 2[1]                              |  <- Is it valid ?  (Finite scan to check validity)  
 |   |   Outputs: 6.0->David, 2.0->Alice           |      
 |   |                            (Signed by Alice)|          
 |   -----------------------------------------------
 |
\ /

-> Transactions explicitly specify the number of inputs and the number of outputs.

-> Transactions also have a unique identifier - here noted by serial number, by actually implemented via "hash pointer";

-> Transaction 1 -> No input since it is newly created , but an output of 25 coins going to Alice, and since it is a new transaction no new coins are created here.

-> Transaction 2 -> Alice wants to send coins to Bob;
Inputs : 1[0] -> 25.0 coins
Outputs : (2) -> Bob (17); (Remainder) -> 8 coins -> payed to change address -> Back to Alice;
Signed by Alice -> validation of the transaction.
**** Always completely need to consume the output of the previous transaction.

-> Here it is much easier to look at the transaction and know whether the transaction is valid or not. It requires a finite scan.
Example: Transaction 4 (By looking at the previous transaction 2[1] -> able to validate the transaction)
Inputs : 2[1] -> Signed By Alice -> Value = (2nd block, 2nd output) = 8;
Outputs : 6.0 -> David, 2.0 -> Alice; = total bitcoins = 8

* Joint Payments
----------------------

 |   -----------------------------------------------
 |   |1                                            |
 |   |   Inputs: ∅                                 |   (First transaction)
 |   |   Outputs: 25.0 -> Alice                    |      
 |   |                                             |          
 |   -----------------------------------------------
T|   |2                                            |
I|   |   Inputs: 1[0]                              |      
M|   |   Outputs: 17.0->Bob, 8.0->Alice            |      
E|   |                            (Signed by Alice)|          
 |   -----------------------------------------------
 |   |3                                            |
 |   |   Inputs: 2[0]                              |      
 |   |   Outputs: 8.0->Carol, 7.0->Bob             |      
 |   |                              (Signed by Bob)|          
 |   -----------------------------------------------
 |   |4                                            |
 |   |   Inputs: 2[1]                              |    
 |   |   Outputs: 6.0->David, 2.0->Alice           | ----     
 |   |                            (Signed by Alice)|    |  6 -> David     
 |   -----------------------------------------------    |  2 -> Alice
 |   |5                                            |    |
 |   |   Inputs: 4[0], 4[1]                        | <--|   
 |   |   Outputs: 6.0->Bob                         |  <--- Joint Payment (2 inputs, 1 outputs)
 |   |        (Signed by David) , (Signed by Alice)|  <--- 2 Signatures                
 |   -----------------------------------------------
 |
\ /

The real deal : A Bitcoin transaction
--------------------
-> It's actually a compact binary format of the data shown that it gets compiled into.
-> Data structure - 3 parts - Metadata, inputs, outputs.

1. Metadata
              {
transaction hash -> "hash" : "5a57fdg93....2443",
                    "ver":1,
housekeeping        "vin_sz":2,
                    "vout_sz":1,
                    "lock_time":0, **
                    "size":404,
                     ....
              }             
2. Input
       "in": [
              {
              "prev_out": {
                     "hash": "3be4...89gfh",    <----- Previous transactions
                     "n":0
              },
              "scriptSig": "3f3we46",   <----- Signatures
              },
              ....
            ],
 3. Output
       "out": [
              {
                     "value": "10.235969544",                    <-- Each output can have value.sum(output) < sum(input)
                     "scriptPubKey": "OP_DUP_OP_HASH89324..568   <---- Script - with public key      
                     OP_EQUALVERIFY OP_CHECKSIG"
              },
              ...
       ]
 
 Q . In a typical transaction

a. There is one signature that covers all the inputc  - false
b. Each input contains a signature                    - true 
c. There is one signature that covers all the output  - false
d. Each output contains a signature                   - false

--------------------------------------------------------------------------------------------------------------------------------------
3.2
--------------------------------------------------------------------------------------------------------------------------------------
